-- VHDL Entity ece411.Control.interface
--
-- Created:
--          by - tkalbar2.stdt (dcllnx15.ews.illinois.edu)
--          at - 17:48:21 09/30/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Control IS
   PORT( 
      CheckN        : IN     std_logic;
      CheckP        : IN     std_logic;
      CheckZ        : IN     std_logic;
      LSB           : IN     std_logic;
      MRESP_H       : IN     std_logic;
      Opcode        : IN     LC3b_opcode;
      RESET_L       : IN     std_logic;
      START_H       : IN     std_logic;
      a             : IN     std_logic;
      bit11         : IN     std_logic;
      clk           : IN     std_logic;
      d             : IN     std_logic;
      n             : IN     std_logic;
      p             : IN     std_logic;
      z             : IN     std_logic;
      ALUMuxSel     : OUT    std_logic;
      ALUop         : OUT    LC3b_aluop;
      IMM6MuxSel    : OUT    std_logic;
      JMPSelMux     : OUT    std_logic;
      JSRSel        : OUT    std_logic;
      LDBSelMux     : OUT    std_logic;
      LEAMuxSel     : OUT    std_logic;
      LoadIR        : OUT    std_logic;
      LoadMAR       : OUT    std_logic;
      LoadMDR       : OUT    std_logic;
      LoadNZP       : OUT    std_logic;
      LoadPC        : OUT    std_logic;
      MARMuxSel     : OUT    std_logic;
      MDRBusSel     : OUT    std_logic;
      MDRMuxSel     : OUT    std_logic;
      MREAD_L       : OUT    std_logic;
      MWRITEH_L     : OUT    std_logic;
      MWRITEL_L     : OUT    std_logic;
      PCMDRMuxSel   : OUT    std_logic;
      PCMuxSel      : OUT    std_logic;
      PCTOREGMuxSel : OUT    std_logic;
      R7MuxSel      : OUT    std_logic;
      RFMuxSel      : OUT    std_logic;
      RegWrite      : OUT    std_logic;
      SEXTMuxSel    : OUT    std_logic;
      STBSelMux     : OUT    std_logic;
      StoreSR       : OUT    std_logic;
      TRAPMuxSel    : OUT    std_logic
   );

-- Declarations

END Control ;

--
-- VHDL Architecture ece411.Control.fsm
--
-- Created:
--          by - tkalbar2.stdt (dcllnx15.ews.illinois.edu)
--          at - 17:48:22 09/30/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF Control IS

   TYPE STATE_TYPE IS (
      Decode,
      Reset,
      L_NOT,
      BR2,
      BR1,
      IF2,
      IF1,
      IF3,
      RSHFL,
      LSHF,
      RSHFA,
      shift,
      add_main,
      add_src,
      add_immed,
      and_src,
      and_immed,
      and_main,
      CalcADDR_B,
      LDB1,
      STB1,
      LDB2,
      STB_H,
      CalcADDR_W,
      LDR1,
      STR1,
      LDR2,
      STR2,
      STB_L,
      INDIR1,
      INDIR2,
      LEA,
      JMP_RET,
      JSR1,
      JSR2,
      TRAP_ADDR,
      TRAP_LD,
      TRAP_PC
   );
 
   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state";

   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      RESET_L
   )
   -----------------------------------------------------------------
   BEGIN
      IF (RESET_L = '0') THEN
         current_state <= Reset;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      CheckN,
      CheckP,
      CheckZ,
      LSB,
      MRESP_H,
      Opcode,
      START_H,
      a,
      current_state,
      d,
      n,
      p,
      z
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Decode => 
            IF (Opcode = op_add) THEN 
               next_state <= add_main;
            ELSIF (Opcode = op_and) THEN 
               next_state <= and_main;
            ELSIF (Opcode = op_not) THEN 
               next_state <= L_NOT;
            ELSIF ((Opcode = op_ldr) OR
                   (Opcode = op_str) OR
                   (Opcode = op_ldi) OR
                   (Opcode = op_sti)) THEN 
               next_state <= CalcADDR_W;
            ELSIF ((Opcode = op_ldb) OR
                   (Opcode = op_stb)) THEN 
               next_state <= CalcADDR_B;
            ELSIF (Opcode = op_br) THEN 
               next_state <= BR1;
            ELSIF (Opcode = op_shf) THEN 
               next_state <= shift;
            ELSIF (Opcode = op_lea) THEN 
               next_state <= LEA;
            ELSIF ((Opcode = op_jmp) OR
                   (Opcode = op_ret)) THEN 
               next_state <= JMP_RET;
            ELSIF ((Opcode = op_jsr) OR
                   (Opcode = op_trap)) THEN 
               next_state <= JSR1;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN Reset => 
            IF (START_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= Reset;
            END IF;
         WHEN L_NOT => 
            next_state <= IF1;
         WHEN BR2 => 
            next_state <= IF1;
         WHEN BR1 => 
            IF (((n AND CheckN) OR
                (p and CheckP) OR
                (z and CheckZ)) = '1') THEN 
               next_state <= BR2;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN IF2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF3;
            ELSE
               next_state <= IF2;
            END IF;
         WHEN IF1 => 
            next_state <= IF2;
         WHEN IF3 => 
            next_state <= Decode;
         WHEN RSHFL => 
            next_state <= IF1;
         WHEN LSHF => 
            next_state <= IF1;
         WHEN RSHFA => 
            next_state <= IF1;
         WHEN shift => 
            IF (d = '0') THEN 
               next_state <= LSHF;
            ELSIF (a = '0') THEN 
               next_state <= RSHFL;
            ELSE
               next_state <= RSHFA;
            END IF;
         WHEN add_main => 
            IF (a = '1') THEN 
               next_state <= add_immed;
            ELSE
               next_state <= add_src;
            END IF;
         WHEN add_src => 
            next_state <= IF1;
         WHEN add_immed => 
            next_state <= IF1;
         WHEN and_src => 
            next_state <= IF1;
         WHEN and_immed => 
            next_state <= IF1;
         WHEN and_main => 
            IF (a = '1') THEN 
               next_state <= and_immed;
            ELSE
               next_state <= and_src;
            END IF;
         WHEN CalcADDR_B => 
            IF (opcode = op_stb) THEN 
               next_state <= STB1;
            ELSIF (opcode = op_ldb) THEN 
               next_state <= LDB1;
            ELSE
               next_state <= CalcADDR_B;
            END IF;
         WHEN LDB1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDB2;
            ELSE
               next_state <= LDB1;
            END IF;
         WHEN STB1 => 
            IF (LSB = '1') THEN 
               next_state <= STB_H;
            ELSE
               next_state <= STB_L;
            END IF;
         WHEN LDB2 => 
            next_state <= IF1;
         WHEN STB_H => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB_H;
            END IF;
         WHEN CalcADDR_W => 
            IF (opcode = op_ldr) THEN 
               next_state <= LDR1;
            ELSIF (opcode = op_str) THEN 
               next_state <= STR1;
            ELSIF ((opcode = op_ldi) OR
                   (opcode = op_sti)) THEN 
               next_state <= INDIR1;
            ELSE
               next_state <= CalcADDR_W;
            END IF;
         WHEN LDR1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDR2;
            ELSE
               next_state <= LDR1;
            END IF;
         WHEN STR1 => 
            next_state <= STR2;
         WHEN LDR2 => 
            next_state <= IF1;
         WHEN STR2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STR2;
            END IF;
         WHEN STB_L => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB_L;
            END IF;
         WHEN INDIR1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= INDIR2;
            ELSE
               next_state <= INDIR1;
            END IF;
         WHEN INDIR2 => 
            IF ((opcode = op_sti)) THEN 
               next_state <= STR1;
            ELSIF (opcode = op_ldi) THEN 
               next_state <= LDR1;
            ELSE
               next_state <= INDIR2;
            END IF;
         WHEN LEA => 
            next_state <= IF1;
         WHEN JMP_RET => 
            next_state <= IF1;
         WHEN JSR1 => 
            IF (Opcode = op_jsr) THEN 
               next_state <= JSR2;
            ELSIF (Opcode = op_trap) THEN 
               next_state <= TRAP_ADDR;
            ELSE
               next_state <= JSR1;
            END IF;
         WHEN JSR2 => 
            next_state <= IF1;
         WHEN TRAP_ADDR => 
            next_state <= TRAP_LD;
         WHEN TRAP_LD => 
            IF (MRESP_H = '1') THEN 
               next_state <= TRAP_PC;
            ELSE
               next_state <= TRAP_LD;
            END IF;
         WHEN TRAP_PC => 
            next_state <= IF1;
         WHEN OTHERS =>
            next_state <= Reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      ALUMuxSel <= '0';
      ALUop <= "000";
      IMM6MuxSel <= '0';
      JMPSelMux <= '0';
      JSRSel <= '0';
      LDBSelMux <= '0';
      LEAMuxSel <= '0';
      LoadIR <= '0';
      LoadMAR <= '0';
      LoadMDR <= '0';
      LoadNZP <= '0';
      LoadPC <= '0';
      MARMuxSel <= '0';
      MDRBusSel <= '0';
      MDRMuxSel <= '0';
      MREAD_L <= '1';
      MWRITEH_L <= '1';
      MWRITEL_L <= '1';
      PCMDRMuxSel <= '0';
      PCMuxSel <= '0';
      PCTOREGMuxSel <= '0';
      R7MuxSel <= '0';
      RFMuxSel <= '0';
      RegWrite <= '0';
      SEXTMuxSel <= '0';
      STBSelMux <= '0';
      StoreSR <= '1';
      TRAPMuxSel <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN L_NOT => 
            ALUop <= alu_not;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN BR2 => 
            PCMuxSel <= '1';
            LoadPC <= '1';
         WHEN IF2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN IF1 => 
            LoadMAR <= '1';
            LoadPC <= '1';
         WHEN IF3 => 
            LoadIR <= '1';
         WHEN RSHFL => 
            ALUop <= alu_srl;
            ALUMuxSel <= '1';
            SEXTMuxSel <='1';
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN LSHF => 
            ALUop <= alu_sll;
            ALUMuxSel <= '1';
            SEXTMuxSel <='1';
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN RSHFA => 
            ALUop <= alu_sra;
            ALUMuxSel <= '1';
            SEXTMuxSel <='1';
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN add_src => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ALUMuxSel <= '0';
         WHEN add_immed => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ALUMuxSel <= '1';
            SEXTMuxSel <= '1';
         WHEN and_src => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN and_immed => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ALUMuxSel <= '1';
            SEXTMuxSel <= '1';
         WHEN CalcADDR_B => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
            SEXTMuxSel <= '1';
            IMM6MuxSel <= '1';
         WHEN LDB1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN STB1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
            STBSelMux <= '1';
         WHEN LDB2 => 
            RegWrite <= '1';
            LoadNZP <= '1';
            LDBSelMux <= '1';
         WHEN STB_H => 
            MWRITEH_L <= '0' after 6ns;
         WHEN CalcADDR_W => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN LDR1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN STR1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN LDR2 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STR2 => 
            MWRITEL_L <= '0' after 6ns;
            MWRITEH_L <= '0' after 6ns;
         WHEN STB_L => 
            MWRITEL_L <= '0' after 6ns;
         WHEN INDIR1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN INDIR2 => 
            LoadMAR <= '1';
            MDRBusSel <= '1';
            MARMuxSel <= '1';
         WHEN LEA => 
            LEAMuxSel <= '1';
            ALUop <= alu_pass;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN JMP_RET => 
            JMPSelMux <= '1';
            LoadPC <= '1';
         WHEN JSR1 => 
            R7MuxSel <= '1';
            PCTOREGMuxSel <= '1';
            RegWrite <= '1';
         WHEN JSR2 => 
            JSRSel <= '1';
            LoadPC <= '1';
         WHEN TRAP_ADDR => 
            TRAPMuxSel <= '1';
            LoadMAR <= '1';
         WHEN TRAP_LD => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN TRAP_PC => 
            PCMDRMuxSel <= '1';
            LoadPC <= '1';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
